description "late rcS actions"

start on started hal
stop on stopping hal

console none

script
    #mount /home; fix filesystem and retry mounting if 1st attempt fails
    mount_home ()
    {
    if ! grep -q -E '^\s*[^\s]+\s+/home\s' /etc/fstab; then
      # /home is not in fstab so is part of rootfs and already mounted
      return 0
    fi
    if [ "$home_fsck" != "0" ]; then
      echo "`date +'%Y-%m-%d %H:%M:%S'`  fsck -a /home" >> /var/log/fsck_home.log
      fsck -a /home >> /var/log/fsck_home.log 2>&1 || true
      echo "" >> /var/log/fsck_home.log
    fi
    /bin/mount /home && grep -q '^[^\ ]* /home [^\ ]* [^\ ]*rw.*' /proc/mounts
    if [ $? -eq 0 ]
    then
      return 0
    else
      grep -q '^[^\ ]* /home [^\ ]* [^\ ]*ro.*' /proc/mounts
      if [ $? -eq 0 ]
      then
        umount /home
      fi
      echo "`date +'%Y-%m-%d %H:%M:%S'`  fsck -y /home" >> /var/log/fsck_home.log
      fsck -y /home >> /var/log/fsck_home.log 2>&1 || true
      echo "" >> /var/log/fsck_home.log
      sync
      /bin/mount /home && grep -q '^[^\ ]* /home [^\ ]* [^\ ]*rw.*' /proc/mounts
      return $?
    fi
    }

    ACT_DEAD=0
    HOME_MOUNTED=0

    #check act_dead
    if [ -e /tmp/ACT_DEAD ]; then
      ACT_DEAD=1
    fi

    # Backup old fsck logs, max size is 512kB
    if [ -e /var/log/fsck.log ]; then
        FSCK_SIZE=`du -sk /var/log/fsck.log | cut -f1`
        if [ $FSCK_SIZE -ge 512 ]; then
            mv /var/log/fsck.log /var/log/fsck.log.old || true
        fi
    fi
    if [ -e /var/log/fsck_home.log ]; then
        FSCK_HOME_SIZE=`du -sk /var/log/fsck_home.log | cut -f1`
        if [ $FSCK_HOME_SIZE -ge 512 ]; then
            mv /var/log/fsck_home.log /var/log/fsck_home.log.old || true
        fi
    fi

    # Load fstab and mount options
    . /etc/default/mount-opts || true

    if [ ! -e /etc/fstab ] || [ "$genfstab" != "0" ]; then

      fstab=/etc/fstab
      tmp_fstab=/tmp/fstab

      # Find internal eMMC device, fallback to mmcblk0
      for emmc in mmcblk1 mmcblk0; do
        if [ ! -e /dev/$emmc ]; then continue; fi
        device=`stat /dev/$emmc | sed -n 's/.*Device type: //p'`
        major=`echo $device | sed 's/,.*//'`
        minor=`echo $device | sed 's/.*,//'`
        major=$((0x$major))
        minor=$((0x$minor))
        if grep -q internal /sys/dev/block/$major:$minor/device/../slot_name; then
          break
        fi
      done

      # Check if / is on ubi
      if grep -q '^ubi0:rootfs / ubifs' /proc/mounts; then
        root_is_ubi=1
      else
        root_is_ubi=0
      fi

      # MyDocs will be first eMMC partition, /home will be second
      mydocs=/dev/${emmc}p1
      home=/dev/${emmc}p2

      mydocs_type=`blkid -c /dev/null -o value -s TYPE $mydocs`
      home_type=`blkid -c /dev/null -o value -s TYPE $home`

      [ -z "$mydocs_type" ] && mydocs_type=vfat;
      [ -z "$home_type" ] && home_type=ext3;

      eval mydocs_opts=$common_opts,$user_opts,\$${mydocs_type}_opts
      eval home_opts=$common_opts,$root_opts,\$${home_type}_opts

      # Remove duplicate commas from variables
      mydocs_opts=`echo $mydocs_opts | sed ':l;s/,,/,/g;tl;s/^,//;s/,$//'`
      home_opts=`echo $home_opts | sed ':l;s/,,/,/g;tl;s/^,//;s/,$//'`

      [ -z "$mydocs_opts" ] && mydocs_opts=defaults
      [ -z "$home_opts" ] && home_opts=defaults

      swaps=`blkid -c /dev/null -o device -t TYPE=swap`

      if [ "$swap_sd" = "0" ]; then
        swaps=`echo $swaps | tr ' ' '\n' | grep $emmc || true`
      fi

      # Generate fstab
      rm -f $tmp_fstab
      echo "# This file was generated by script /etc/event.d/rcS-late" >> $tmp_fstab
      echo "# !!! Do not edit this file. It will be overwritten in next device startup !!!" >> $tmp_fstab
      echo "# If you want static /etc/fstab add genfstab=\"0\" to file /etc/default/mount-opts-overwrite" >> $tmp_fstab

      # /
      grep '^[^\ ]* / ' /proc/mounts >> $tmp_fstab || true

      # /home
      if [ $root_is_ubi -eq 1 ]; then
        echo "$home /home $home_type $home_opts 0 2" >> $tmp_fstab
      fi

      # /opt
      if [ $root_is_ubi -eq 1 ] || [ ! -e /opt ] || [ -d /opt -a -z "`ls -A /opt`" ]; then
        echo "/home/opt /opt none bind 0 0" >> $tmp_fstab
      fi

      # /home/user/MyDocs
      echo "$mydocs /home/user/MyDocs $mydocs_type $mydocs_opts 0 2" >> $tmp_fstab

      # swap
      for dev in $swaps; do
        echo "$dev none swap sw 0 0" >> $tmp_fstab
      done

      cmp -s $tmp_fstab $fstab || cp $tmp_fstab $fstab
      rm -f $tmp_fstab

    fi

    if [ $ACT_DEAD -eq 0 ]; then
      /sbin/swapon -a || echo "Failed to enable paging partition."
      # Setup lowmem module
      echo 32768  > /proc/sys/vm/lowmem_deny_watermark_pages || true
      echo 98304  > /proc/sys/vm/lowmem_notify_high_pages || true
      echo 131072 > /proc/sys/vm/lowmem_notify_low_pages || true
      echo 1024   > /proc/sys/vm/lowmem_nr_decay_pages || true
      # Exclude some UIDs from memory allocation denial.
      # 30000 is messagebus, 30001 could be used by Matchbox
      echo "30000 30001 30002 30003" > /proc/sys/vm/lowmem_allowed_uids || true
    fi

    mount_home && HOME_MOUNTED=1

    # If failed to mount /home and system has been already optified - reboot 
    if [ $HOME_MOUNTED -eq 0 ]
    then
      if [ -e /var/lib/maemo-optify-firstboot-do-not-clean-home-opt ]; then
        telinit 6
      fi
    else
      [ ! -d /home/opt ] && mkdir /home/opt
      [ ! -d /opt ] && mkdir /opt
    fi

    if [ $ACT_DEAD -eq 0 ]
    then
      if [ $HOME_MOUNTED -eq 1 ]
      then
        if [ -x /usr/sbin/maemo-optify-firstboot.sh ]; then
            . /usr/sbin/maemo-optify-firstboot.sh
        fi
      fi
    fi

    /bin/mount /opt || echo "Failed to mount(bind) /opt."

    if [ $ACT_DEAD -eq 0 ]
    then
      if [ $HOME_MOUNTED -eq 1 ]
      then
        if [ -x /usr/sbin/maemo-optify-auto-opt.sh ]; then
            . /usr/sbin/maemo-optify-auto-opt.sh
        fi
      fi

      if [ -d /home/preinstalled -a -d /home/user ]
      then
        rm -rf /home/user
      fi

      if [ ! -d /home/user ]
      then
        if [ -d /home/preinstalled ]
        then
          mv /home/preinstalled /home/user
        else
          mkdir /home/user
        fi
        cd /etc/skel
        cp -a . /home/user
        chown -R user:users /home/user
        sync
      fi
    fi

    if [ ! -d /home/user ]
    then
      mkdir /home/user
      chown user:users /home/user
      sync
    fi

    # We can safely continue booting now.
    initctl emit MOUNTS_OK

    # Adjust flushing of memory card buffers
    echo 40 > /proc/sys/vm/dirty_ratio
    echo 10 > /proc/sys/vm/dirty_background_ratio

    # Initialize PRNG pool with the HW RNG. Slow, but that's ok.
    URANDOM_POOLSZ=512
    if [ -e /dev/hwrng ]; then
      RANDOM=/dev/hwrng
    elif [ -e /dev/hw_random ]; then
      RANDOM=/dev/hw_random
    fi
    if [ -e "$RANDOM" ]; then
      echo "Seeding entropy pool"
      dd if=$RANDOM of=/dev/urandom bs=$URANDOM_POOLSZ count=1
    fi

    # Data for the panic info driver
    mount -t debugfs nodev /sys/kernel/debug
    if modprobe panic_info_buff; then
      OSSO_VERSION="$(osso-product-info 2>/dev/null || true)"
      CSSU_VERSION="CSSU_VERSION='$(dpkg-query -W -f \${Version} mp-fremantle-community-pr 2>/dev/null || echo '<unknown>')'"
      KERNEL_VERSION="KERNEL_VERSION='$(uname -a 2>/dev/null || echo '<unknown>')'"
      sleep 1
      printf "%s\n%s\n%s" "$OSSO_VERSION" "$CSSU_VERSION" "$KERNEL_VERSION" > /sys/kernel/debug/panic_info_buff || true
    fi
end script

normal exit 0
